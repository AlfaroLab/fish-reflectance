---
title: "lab-report1"
output:
  html_document: default
  word_document: default
  pdf_document: default
date: "2025-03-01"
---


## Feb 28

### Alfa Angle Calculation and Visualization

First step: reading in the data file
```{r}
library(here)

here("/Users/josephdekel/Desktop/UCLA/Winter\ 25/SRP\ 199/Week\ 6", "varied_spectra.csv" )

df <- read.csv("varied_spectra.csv")

```
I first created synthetic data that would effectively demonstrate how different patches on fish can be distinguished using hyperspectral measurements. The varied_spectra.csv file was designed to contain five measurements per patch type, simulating natural variation while maintaining distinct spectral signatures and characteristic spectral patterns that mirror biological reality.


Function to calculate the spectral angle:
```{r}
# Calculating spectral angle between two spectra (x and y)
calc_spectral_angle <- function(x, y) 
{
  sum_xy <- sum(x * y)    
  sum_x2 <- sum(x^2)      
  sum_y2 <- sum(y^2)
  alfa <- acos(sum_xy / sqrt(sum_x2 * sum_y2))
  return(alfa)  # Returning angle in radians
}
```
The code implementation centres around the spectral angle calculation function, which implements the formula from the paper: α = cos⁻¹(ΣXY/√(Σ(X)²Σ(Y)²)). This calculation is crucial for identifying the most representative measurement for each patch type by finding the measurement closest to the mean. The function returns angles in radians, providing a standardized measure of similarity between spectra.


First Plot:
```{r}
# Creating first plot (initialized with first measurement)
plot(df[,1], df[,2],       # Plotting wavelength (col 1) vs first measurement (col 2) 
     type="l",             # Line plot
     ylim=c(0,100),        # Y-axis from 0 to 100%
     xlab="Wavelength (nm)", 
     ylab="Reflectance (%)",
     main="Patch Measurements and Means")

# Defining colors and patch names for plotting
colors <- c("black", "blue", "orange", "gray")    # Colour for each patch
patches <- c("black", "blue", "orange", "white")  # Names of patches

# Ploting all individual measurements for each patch
for(patch in patches) 
{
  patch_cols <- grep(patch, names(df))         # Finding all columns for this patch
  for(col in patch_cols)                       # Loop through each column of this patch
    {
    lines(df[,1], df[,col],                    # Adding line for each measurement
          col=colors[which(patches == patch)]) # Using corresponding colour
  }
}

# Calculating & plotting mean spectra
means <- data.frame(wavelength = df[,1])        # Creating dataframe for means
for(patch in patches) 
{
  patch_cols <- grep(patch, names(df))          # Finding columns for this patch
  means[[patch]] <- rowMeans(df[,patch_cols])   # Calculating mean spectrum
  lines(df[,1], means[[patch]],                 # Plotting mean as thicker line
        col=colors[which(patches == patch)], 
        lwd=3)                                  
}

# Legend for first plot
legend("topleft", patches, col=colors, lwd=2)
```

The plot displays all measurements and means, with individual measurements shown as thin lines and means as thicker lines in corresponding colours. This visualization demonstrates the variation within patches while maintaining clear distinction between patch types.

Finding representative spectrum (smallest α) for each patch:
```{r}
# Finding representative spectrum (smallest α) for each patch
rep_spectra <- data.frame(wavelength = df[,1])  # Creating dataframe for representative spectra (starting with wavelengths)
for(patch in patches) 
{
  patch_cols <- grep(patch, names(df))          # Finding all columns for this patch
  mean_spec <- means[[patch]]                   # Getting mean spectrum we calculated earlier
  angles <- numeric(length(patch_cols))         # Creating empty vector to store angles
  
  # Calculating spectral angle between each measurement and mean
  for(i in seq_along(patch_cols)) 
  {
    angles[i] <- calc_spectral_angle(df[,patch_cols[i]], mean_spec)
  }
  
  # Selecting measurement with smallest angle as representative
  rep_spectra[[patch]] <- df[,patch_cols[which.min(angles)]]
  
  # Printing the smallest angle found
  cat(sprintf("%s patch - smallest angle: %f\n", patch, min(angles)))
}
```

Second Plot:
```{r}
# Creating second plot - representative spectra
plot(rep_spectra$wavelength, rep_spectra$black,   # Initialize with black patch
     type="l", 
     ylim=c(0,100),
     xlab="Wavelength (nm)", 
     ylab="Reflectance (%)",
     main="Representative Spectra (Smallest α)",
     col="black")

# Adding lines for other patches
lines(rep_spectra$wavelength, rep_spectra$blue, col="blue")
lines(rep_spectra$wavelength, rep_spectra$orange, col="orange")
lines(rep_spectra$wavelength, rep_spectra$white, col="gray")

# Legend for second plot
legend("topleft", patches, col=colors, lwd=1)
```

This plot shows only the representative spectra (those closest to the mean), providing a cleaner visualization for quick comparison between patches.


The data processing flow moves systematically from reading the CSV file through plotting all measurements, calculating means, finding representative spectra using spectral angles, and finally creating the comparative plots. The implementation uses nested loops for efficiency, with the outer loop processing each patch type and the inner loop handling individual measurements. The grep function identifies relevant columns for each patch type. In the code, the wavelength column positioned first for easy reference.

Colour choices in the visualization match the actual patch colours for intuitive interpretation, with line thickness differentiating means from individual measurements. The y-axis range of 0-100% covers the full possible reflectance range, while the wavelength range matches the visible spectrum. This approach provides a practical demonstration of the spectral analysis methods described in the Piranha paper, allowing both examination of variation within patches and comparison between different patch types.

